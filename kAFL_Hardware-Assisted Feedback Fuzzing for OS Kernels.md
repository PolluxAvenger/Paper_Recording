# kAFL:Hardware-Assisted Feedback Fuzzing for OS Kernels

标签（空格分隔）： Paper

---

## 论文来源
USENIX Security 2017

## 工作简介
尽管内核组件中的漏洞更严重，但大多数 Fuzzing 工作（特别是反馈型 Fuzzing）仅限于操作系统的用户态组件，因为它们允许攻击者以完全权限访问系统

但由于反馈机制不容易应用，所以内核组件很难进行模糊测试。另外由于中断、内核线程、无状态和类似的机制造成了不确定性。以及内核的崩溃极其影响 Fuzzer 的性能，因为需要等待操作系统重启

我们利用 Hypervisor 和 Intel Processor Trace(PT) 技术。保持与操作系统的独立性，即使在操作系统崩溃的情况下，我们的方法也几乎不引入性能开销

优势：

 - 操作系统独立：利用 Hypervisor（VMM）产生覆盖率，可以通过几乎与操作系统无关的方式反馈驱动闭源内核组件的模糊测试
 - 硬件辅助反馈：利用了 Intel Processor Trace(PT) 技术，性能开销非常小。自研 PT 解码器比 Intel 的 ptxed 解码器快 30 倍。因此获得了完整的跟踪信息，以此指导模糊测试最大化测试覆盖率
 - 可扩展与模块化设计：分为 Fuzzer、跟踪引擎和测试目标三部分，这样无需为指定操作系统开发驱动程序


## 工作背景
用户态下的几个已知漏洞类型，如内存破坏、竞态条件内存访问以及 UAF 等，也在操作系统内核中存在。在过去，由于用户态程序的漏洞容易可靠地利用，攻击者更关注用户态应用程序。然而随着各种防御机制的出现，用户态漏洞利用变得越来越困难，攻击者又将目光转向了内核

由于担心性能影响，大部分内核防御机制在实践中并未广泛部署，以及很多防御机制不是官方主线代码库的一部分，甚至不需要支持最新的 CPU 扩展（SMAP/SMEP）

长期以来，Fuzzing 一直是测试与构建软件质量的关键组件，随着 AFL 的发展，Smart Fuzzer 在研究领域与工业界都得到了巨大推动，Google 的 OSS Fuzz 项目进一步扩大了这一影响，该项目在应用程序中成功发现并持续发现高安全威胁的关键性缺陷。随后，DARPA 的 CGC 比赛表明，漏洞挖掘中的新技术仍然和 Fuzzing 高度相关

与用户态相比，对内核进行模糊测试有一系列额外的挑战：

 - 崩溃和超时要求使用虚拟化来捕获缺陷
 - 内核代码比一般的 ring3 程序具有更多的不确定性
 - 中断、内核线程、无状态和类似的机制
 - 除了普通中断或 sysenter 指令外，没有等同于命令行参数或 stdin 等内核与驱动程序交互的通用方式
 - Windows 内核以及许多相关的驱动程序和核心组件都是闭源代码

前人的工作依赖于某些驱动程序或重新编译，由于其采用仿真收集反馈或者非反馈驱动，所以都很慢

利用了新的 CPU 特性，开销非常小，小于 5%。Intel 的 Processor Trace（PT）技术提供正在运行代码的控制流信息，可以使用这些信息构建一个类似于 AFL 插桩的反馈机制

## 技术背景
使用 IA-32 CPU 的 Intel Processor Trace(PT) 技术扩展来获取任意操作系统 ring0 的覆盖度信息。为了提高效率与实现操作系统独立，我们也使用了 Intel 的硬件虚拟化技术（Intel VT-x）

### 虚拟内存布局
每个 x86-64 操作系统都使用分拆式的虚拟内存布局：内核通常位于每个虚拟内存空间的上半部分，每个用户态进程内存位于下半部分。受限于当前 CPU 的 48 位虚拟地址限制，Linux 的虚拟内存空间的上半部分（内核空间）和下半部分（用户空间）的大小都为 2<sup>47</sup>（128T）

内核内存可以映射到任意虚拟地址空间，且始终相同。如果用用户态进程执行用于与内核交互的 syscall/sysenter 指令或触发必须由操作系统处理的异常，操作系统将保持当前的 CR3，不切换虚拟内存地址空间。相反，当前的虚拟内存地址空间被重用，内核会在相同的地址空间内处理当前与用户态进程相关的任务

### Intel VT-x
首先要区分三种 CPU，物理 CPU、逻辑 CPU 和虚拟 CPU(vCPU)。物理 CPU 是硬件的 CPU，大多数 CPU 都支持超线程技术来提升多线程性能的机制，这种情况下，一个物理 CPU 上有多个逻辑 CPU，不同的逻辑 CPU 交替执行，有效地利用可用资源、减少调度开销。操作系统通常将每个逻辑 CPU 视为整个 CPU，可以在每个逻辑 CPU 上创建多个硬件支持的虚拟机。这种情况下，每个虚拟机都有一组虚拟 CPU

虚拟化角色模型分为两个组件：虚拟机监视器（VMM）与虚拟机。VMM 也叫 Hypervisor 或 Host，是一套对物理硬件具有完全控制权限的特权软件，并且为虚拟 Guest 系统提供对物理资源的有限访问。VM 也叫 Guest，是一个在 VMM 提供的虚拟上下文环境中透明执行的系列软件

为了提供完整的硬件辅助虚拟化支持，Intel VT-x 为众所周知的基于环的标准执行模型添加了两种额外的执行模式。默认的执行模式被称为 VMX OFF，它没有实现任何硬件虚拟化支持。当使用硬件支持的虚拟化时，CPU 切换到 VMX ON 状态以区分两种不同的执行模式。Hypervisor 的高权限模式（VMM root 或 VMM）和虚拟机 Guest 的低权限模式（VMX non-root 或 VM）

当运行在 Guest 模式时，VM Guest 虚拟机中的若干特权操作将触发 VM-Exit 事件并将控制权转交给 Hypervisor。通过这种方式，可以运行虚拟机内期望有权访问硬件的任意软件。与此同时，更高权限的管理可以通过极小的性能开销来控制要执行的操作

要创建、启动、控制虚拟机，VMM 必须为每个 vCPU 使用一个虚拟机控制结构（VMCS），其中包含有关当前状态的所有重要信息以及如何执行 vCPU 的 VMX 转换

### Intel Processor Trace
在第五代 Intel 酷睿处理器（Broadwell 结构）中，Intel 推出了 Intel Processor Trace(PT) 技术，提供执行和分支跟踪信息。与其他分支跟踪技术不同，输出缓冲区的大小不再受特殊寄存器的严格限制，相反地只受内存大小的限制。如果输出对象被反复清空，可以创建任意长度的 Trace

处理器的输出格式是面向 packet 的，分为两种类型：通用执行信息与控制流信息。Intel Processor Trace 在运行时产生各种类型的与控制流相关的 packet 类型。为了从跟踪数据中获得控制流信息，我们需要一个解码器。解码器需要跟踪软件来解析这些包含条件分支地址的 packet

Intel 指定了影响执行的五种控制流程类型，称为流程指令更改（CoFI），不同类型的执行将导致不同的流信息 packet 序列：

 - Taken-Not-Taken (TNT)：如果处理器执行任何条件跳转，则判断该跳转是否执行，以及是否可编码为 TNT packet 中
 - Target IP (TIP)：如果处理器执行间接跳转或转移指令，解码器将无法恢复控制流。因为处理器在执行 indirect branch、near ret、far transfer 类型的指令时会产生 TIP packet。这些 TIP packet 将在转移或跳转发生之后处理器执行的相应的目标指令指针存储下来
 - Flow Update Packets (FUP)：异步事件（中断或陷阱）必须为软件解码器产生 hint packet。这些事件被记录为 FUP，并且通常在 TIP 后表明后续指令

为了限制生成的跟踪数据量，Intel PT 为运行时过滤提供了多个选项：

 - 根据给定的处理器，可以配置指令指针过滤的多个范围（IP Filter）。通常，如果启用了分页，这些过滤范围仅影响虚拟地址。这可以将 tarce 生成限定在指定的范围内，从而避免多余的 trace 生成
 - 根据 IP 过滤机制，可以通过保护环模型（例如 ring 0 或 ring 3）的当前特权级别（CPL）过滤 trace。该过滤器允许我们根据用户态（CPL> 0）或内核态（CPL = 0）来过滤 trace
 - 要将 trace 生成限制为一个特定的虚拟内存地址空间，软件可以使用 CR3 过滤器。如果 CR3 值与配置的过滤器值相匹配，Intel PT 将仅生成相匹配的 trace。CR3 寄存器包含指向当前页表的指针。因此，CR3 寄存器的值可用于过滤代表某个 ring 3 进程执行的代码，即使在 ring 0 模式下也是如此

Intel PT 还支持输出数据的各种可配置目标域。kAFL 专注于物理地址表（ToPA）机制，该机制使我们能够指定多个输出区域：每个 ToPA 表包含多个 ToPA 条目，这些条目又包含用于存储 trace 的关联内存块的物理地址。ToPA 条目中除了物理地址，还有物理内存中引用的内存块的大小以及多个类型位。这些类型指定 CPU 在访问 ToPA 条目时的行为，以及如何处理填充的输出区域

## 工作设计
系统分为三个组件：Fuzzing 逻辑、虚拟机基础设施（QEMU-PT 和 KVM-PT）和用户模式代理

![image_1c7tmebg31joh49n1a4p14n71fgh9.png-32.1kB][1]

一般情况下，Guest 只能通过 hypercall 与 Host 进行通信。Host 可以读写 Guest 内存，在请求处理完成后继续执行虚拟机

![image_1c7uupbjd1hpe1d9h1fi719681u5mm.png-58.3kB][2]

当虚拟机启动时，用户模式代理的第一部分（装载器）使用 hypercall HC_SUBMIT_PANIC 将内核错误处理程序的地址（Windows 中 BugCheck 的内核地址）装载到 QEMU-PT。① 之后，QEMU-PT 会在错误处理程序的地址处 patch 一个 hypercall 调用例程。这使得我们能够快速响应虚拟机中的 Crash，而不是等待超时/重新启动。而后，装载器使用 hypercall HC_GET_PROGRAM 请求并启动实际的用户模式代理

②装载程序完成后，Fuzzer 开始初始化。代理会触发一个 HC_SUBMIT_CR3 的 hypercall 交由 KVM-PT 处理。Hypervisor 提取当前正在运行的进程的 CR3 值，交给 QEMU-PT 进行筛选

③最后，代理使用 hypercall HC_SUBMIT_BUFFER 通知 Host 它期望其输入的地址。此时 Fuzzer 安装完毕，Fuzzing 循环开始，循环中，代理使用 HC_GET_INPUT 的 hypercall 请求一个新样本

④Fuzzing 产生一个新的样本发送到 QEMU-PT。因为 QEMU-PT 可以完全访问 Guest 的内存空间，所以他只需要将样本复制到代理指定的缓冲区中即可。然后继续执行虚拟机指令

⑤此 VM-Entry 事件启用 PT 跟踪机制，代理处理输入样本与内核交互（例如，将输入样本解释为文件系统映像，并尝试装入）

⑥对内核 Fuzzing 时，QEMU-PT 解码跟踪数据并根据需要更新位图。一旦交互完成，内核将控制权交给代理，代理通过 HC_FINISHED 的 hypercall 通知 Hypervisor。由此产生的 VM-Exit 事件将停止跟踪，QEMU-PT 将对剩下的跟踪数据进行解码

⑦产生的位图将传递给主逻辑，进一步处理

⑧代理可以继续运行任何不需跟踪的清理例程，然后在触发一个 HC_GET_INPUT 来开始下一个循环迭代

### Fuzzing 逻辑
Fuzzing 逻辑作为 Host 操作系统的 ring 3 进程

管理有用的输入样本队列，畸变创建新输入，并对这些输入进行评估。大多数情况下，直接使用 AFL 的算法。与 AFL 类型，我们使用位图来存储基本块转换。我们通过一个接口从虚拟机收集 AFL 的位图到 QEMU-PT，并确定哪些输入样本触发了有用的行为

Fuzzing 逻辑还会协调并行产生的虚拟机的数量。与 AFL 更大的差异之一是 kAFL 的多处理和高并行的特性。AFL 只是产生多个独立的 Fuzzer，这些 Fuzzer 定期同步输入队列。相反，kAFL 并行执行确定性阶段，所有线程都处理最有用的输入样本。时间消耗在不受 CPU 限制的任务（如 Guest 延迟执行）。因此，使用许多并行进程（每个核心多达 5-6 个 CPU）可大大提高 Fuzzing 的效率。因为每个核心的 CPU 的负载都比较高。最后，Fuzzing 逻辑与用户界面进行通信以定期显示统计数据

### 用户模式代理
我们在虚拟化目标操作系统内部运行用户模式代理。 原则上，这个组件只需要通过 hypercall 接口和 Fuzzing 逻辑来同步、收集新的输入样本，并使用它来与 Guest 的内核进行交互。我们的示例代理程序试图将输入样本作为文件系统映像加载的程序，将特定文件（如证书）传递给内核解析器，甚至执行各种系统调用的链

理论上只需要一个组件，实际上我们通过两个不同的组件：第一个是装载程序组件，其通过 hypercall 接口接受任意的二进制文件。该二进制文件也就是第二个组件，即由装载程序组件执行的用户模式代理

装载程序组件会检查用户模式代理是否已经 Crash（对系统调用进行 Fuzzing 时经常发生），并在必要时进行重新启动。这种设置的有点在于我们可以将任何二进制文件传递虚拟机，针对不同的 Fuzzing 组件重用虚拟机快照

### 虚拟基础设施
QEMU-PT 运行在 ring 3，KVM-PT 运行在 ring 0。Fuzzing 逻辑使用 QEMU-PT 和 KVM-PT 进行交互来产生目标虚拟机

KVM-PT 允许我们跟踪单个 vCPU 而不是逻辑 CPU，该组件在 CPU 切换到 Guest 虚拟机执行之前在相应的逻辑 CPU 上配置并启用 Intel PT，并在 VM 退出转换期间禁用跟踪。这样，关联的CPU将只提供虚拟化内核本身的跟踪数据

QEMU-PT 用于与 KVM-PT 接口进行交互，以从用户空间配置和切换 Intel PT，并访问输出缓冲区以解码跟踪数据。解码的跟踪数据被直接转换为已执行的条件分支指令的地址流。此外，QEMU-PT 还基于以前对非确定性基本块的了解，对执行地址流进行过滤，从而防止误报。并将这些结果作为 AFL 兼容位图提供给 Fuzzing 逻辑。我们使用我们自己开发的 PT 解码器来缓存反汇编结果，与 Intel 提供的现成解决方案相比，可以显著提高性能

### 状态与非确定性代码
跟踪操作系统会导致大量的非确定性。非确定性基本块转换的最大来源是中断，可以在任何时间点发生。此外，由于从内存快照重新加载虚拟机的代价很高，因此我们的实现在每次执行后都不会重置整个状态

因此我们必须处理内核的状态和异步问题。有状态代码的一个例子是对 kmalloc() 的简单调用：根据之前分配的数量，kmalloc() 可能会简单地返回一个新指针或映射整个页面并更新大量的元数据。我们使用两种技术应对这些挑战：

 - 处理中断时过滤掉中断和转换。使用英特尔 PT 技术跟踪数据。如果发生中断，处理器将发出 TIP 指令，因为代码中传输不可见。为了避免在间接控制流程指令中发生中断期间的混淆，TIP 数据包被标记为 FUP（流更新数据包）以指示异步事件。识别出这样的签名后，解码器将丢弃所有访问的基本块，直到遇到相应的 iret 指令。要将中断与其对应的 iret 连接起来，我们会跟踪简单调用堆栈上的所有中断，避免中断处理程序被另一个中断中断
 - 将非确定性触发的任何基本块列入黑名单。每当我们在 AFL 位图中遇到一个新位时，我们就连续多次重新运行输入样本。每个没有出现在所有 Fuzzing 中的基本块都将被标记为非确定性的，并从进一步处理中过滤掉。为了快速访问，结果存储在黑名单基本块地址的位图中。在 AFL 位图转换过程中，任何涉及黑名单基本块的转换哈希值（将当前基本块地址与前一个基本块地址组合在一起）将被跳过

### Hypercall
Hypercalls 是虚拟化引入的一项功能。在英特尔平台上，超级调用由vmcall 指令触发。Hypercall 和 VMM 的关系就像系统调用和内核的关系。如果任何 ring 3 进程或 VM 中的内核执行 vmcall 指令，则会触发 VM-Exit 事件，并且 VMM 可以决定如何处理 hypercall。如果在 rax 中传递了一个 Magic Number 并且在 rbx 中设置了适当的 hypercall-ID，我们通过 patch KVM-PT 以将我们自己的一组 hypercalls 传递给 Fuzzing 逻辑。此外，我们还 patch 了 KVM-PT 接受来自 ring 3 的 hypercall。为特定 hypercall 传递的参数通过 rcx 传递

我们使用这种机制来定义用户模式代理和 Fuzzing 逻辑通信的接口。一个示例 hypercall 是 HC_SUBMIT_BUFFER。它的参数是一个存储在 rcx 中的 Guest 指针。执行 vmcall 指令后，会触发 VM-Exit 事件，QEMU-PT 会存储传递的缓冲区指针。它将在稍后将新的输入样本复制到此缓冲区中。最后，继续进行 VM

此接口的另一个作用是在目标操作系统内核发生 Crash 时通知 Fuzzing 逻辑。为了做到这一点，我们用一个简单的 hypercall 例程来覆盖操作系统的内核崩溃处理程序。注入的代码如下所示，并显示了如何在程序集级别使用 hypercall 接口。`cli` 指令禁止所有中断，以避免在 hypercall 过程中出现任何类型的异步干扰

```
cli
mov rax, KAFL_MAGIC_VALUE
mov rbx, HC_CRASH
mov rcx, 0x0
vmcall
```

## 工作评估
### KVM-PT
Intel PT 允许我们跟踪分支转换，而无需 patch 或重新编译目标内核。据我们所知，没有公开可用的驱动程序能够仅使用 Intel PT 长时间跟踪 Guest 中单个 vCPU 的执行情况。例如，Simple-PT 设计不支持的长期跟踪。 perf-subsystem 支持虚拟机 Guest 操作和长期跟踪的跟踪。但是，它旨在跟踪逻辑 CPU，而不是 vCPU。即使跟踪 VMX 执行，数据也会与逻辑 CPU 关联，而不与 vCPU 关联。因此，必须重新组装 VMX 上下文，这是一项昂贵的开销

KVMPT 能够无限期地跟踪 vCPU，而不会产生任何调度副作用或由于溢出输出区域导致的任何跟踪数据丢失。该扩展为 KVM vCPU 提供了一种快速可靠的跟踪机制。此外，与 KVM 一样，此扩展也提供了一个扩展的用户模式界面，以便从用户空间访问此跟踪功能。 QEMU-PT 利用这个接口与 KVM-PT 进行交互并访问生成的跟踪数据

#### vCPU Specific Traces
要启用 Intel PT，运行在 ring 0（在我们的情况下为 KVM-PT）中的软件必须设置模型特定寄存器（MSR）的相应位（IA32_RTIT_CTL_MSR.TraceEn）

跟踪启用后，如果逻辑 CPU 满足配置的过滤器选项，它将跟踪任何执行的代码。修改必须在 CPU 从主机上下文切换到 VM 操作之前完成，否则 CPU 将执行 Guest 代码，并且在技术上无法修改任何主机 MSR。在 CPU 离开 Guest 上下文之后，相反过程是必需的。但是，手动启用或禁用 Intel PT 也会产生包含手动 MSR 修改的跟踪。为防止在 VMM 中收集不需要的跟踪数据，我们使用 Intel VT-x 的 MSR 自动加载功能。可以通过修改 VMCS中的相应条目来启用MSR 自动加载（例如，VM 条目的 VM_ENTRY_CONTROL_MSR）。这会强制 CPU 在 VM-Exit 或 VM-Entry 事件发生后加载已定义 MSR 的预配置值列表。通过启用 MSR 自动加载追踪功能，我们仅收集一个特定 vCPU 的 Intel PT 的追踪数据

#### Continuous Tracing
一旦我们启用了 Intel PT，CPU 就会将跟踪数据写入内存缓冲区，直到它已满。该缓冲区的物理地址以及如何处理完整缓冲区由一系列称为物理地址表（ToPA）条目的数据结构指定

![image_1c7vetvldhi7rj601krijcu13.png-12.2kB][3]

该数组可以包含多个条目，并且必须由单个 END 条目终止。CPU 存在两种不同处理溢出的方式：

 - 停止跟踪（同时继续执行 - 因此导致不完整的跟踪）
 - 引发中断

此中断会导致 VM 退出，因为它不可屏蔽。我们捕获主机上的中断并使用跟踪数据。最后，我们重置缓冲区并继续执行虚拟机。不幸的是，这个中断可能会在填充缓冲区之后的某个特定时间引发

我们的 ToPA 条目配置可以在上图中看到。为了避免丢失跟踪数据，我们使用了两个不同的 ToPA 条目。第一个是主缓冲区。其溢出行为是触发中断。一旦主缓冲区被填满，就会使用第二个条目，直到中断被实际传递。 ToPA 指定另一个较小的缓冲区。溢出第二个缓冲区会导致跟踪停止。为避免由此造成的数据丢失，我们选择的第二个缓冲区，比我们在测试中见过的最大溢出轨迹（4 KB）大四倍。如果第二个缓冲区也溢出，则以下跟踪将包含指示某些数据丢失的 packet。在这种情况下，可以简单地增加第二缓冲区的大小。这样，我们可以为任何数量的跟踪数据获取精确的跟踪

### QEMU-PT
要使用 KVM-PT 扩展 KVM，需要用户空间对应部分。 QEMU-PT 是 QEMU 的扩展，提供对 KVM-PT 用户空间接口的全面支持。 此接口提供了在运行时启用、禁用和配置 Intel PT 的机制以及定期 ToPA 状态检查以避免超载。KVM-PT 可通过 `ioctl()` 命令和 `mmap()` 接口从用户模式访问

除了作为 KVM-PT 的用户级接口之外，QEMU-PT 还包含一个组件，该组件可将跟踪数据解码为更适合 Fuzzing 逻辑的形式：我们对 Intel PT 的 packet 进行解码并将它们转换为类似 AFL 的位图

![image_1c7vg62qc1cogr551vh812c118ap1g.png-20.8kB][4]

#### PT 解码器
针对内核的大量模糊测试每秒可能产生数百兆字节的跟踪数据。为了处理如此大量的输入数据，解码器必须重视效率。否则，解码器可能成为 Fuzzing 过程中的主要瓶颈。尽管如此，解码器也必须是精确的，因为在解码过程中的不准确会导致更多的错误。Intel PT 的解码过程是连续的，并受先前解码的 packet 的影响

为了简化实施 Intel PT 软件解码器的工作，英特尔提供了自己的解码引擎 libipt。libipt 是通用的 Intel PT 解码引擎。但是，它并不适合我们，因为 libipt 解码跟踪数据以提供执行数据和流信息。此外，libipt 不会缓存反汇编指令，并且在我们的用例中表现不佳

由于 kAFL 仅依赖于流信息并且将 Fuzzing 过程重复应用于相同的代码，所以可以优化解码过程。我们的 Intel PT 软件解码器就像一个即时解码器，这意味着只有在根据解码的跟踪数据执行代码段时才会考虑代码段。为了进一步优化查找，所有反汇编的代码段都被缓存。另外，我们简单地忽略与我们的用例无关的 packet

由于我们的 PT 解码器是 QEMU-PT 的一部分，因此如果 ToPA 基本区域被填充，则直接处理跟踪数据。解码过程在原地应用，因为缓冲区可以通过 mmap() 从用户空间直接访问。与其他 Intel PT 驱动程序不同，我们不需要在存储器或存储设备上存储大量跟踪数据以进行事后解码。最终，解码的跟踪数据被转换为 AFL 位图格式

### AFL Fuzzing 逻辑
AFL 最重要的部分是用于跟踪遇到的基本块转换的位图。每个基本块具有随机分配的 ID，并且根据以下公式将为每个从基本块A到另一个基本块B的转换分配给位图的偏移：

![image_1c7vi0jndju61ji11gie2i21aeh2d.png-6.3kB][5]

kAFL 使用基本块的地址代替编译时随机。每次观察到转换时，位图中的相应字节都会增加。在完成模糊迭代之后，位图的每个条目都被舍入，以便只保留最高位。然后将位图与全局静态位图进行比较，以查看是否找到任何新位。如果找到新位，则将其添加到全局位图，并将触发新位的输入样本添加到队列中。当发现一个新的有用的输入时，会执行一个确定性阶段，试图单独变异每个字节

一旦确定性阶段完成，非确定性阶段开始。在非确定性阶段，多个突变在随机位置进行。如果确定性阶段发现新的输入，则非确定性阶段将被延迟，直到已经执行了所有有用的输入样本的所有确定性阶段。如果一个输入样本触发一个全新的转换（而不是改变转换的次数），它将被优先考虑

### 工作对比
ProjectTriforce 是唯一可用的与操作系统无关的反馈模糊器。 TriforceAFL 基于 QEMU 的仿真后端，而不是硬件辅助虚拟化和 Intel PT

通常 kAFL 的吞吐量为每秒 1000 到 4000 次测试。与TriforceAFL的QEMU CPU 仿真相比，kAFL 的性能提高了54倍。单进程执行中的性能提升略低（快 48 倍）

与 KVM-PT 相比，解码器对模糊过程的整体性能有重大影响，因为解码过程不是 Intel PT，因此 KVM-PT 不是硬件加速。并且使用了 Capstone 作为指令解码后端

## 工作思考
存在局限：

 - 特定操作系统的代码。少量与操作系统相关的 ring 3 代码执行三项任务：首先，它与操作系统进行交互，将来自模糊引擎的输入样本转换为与操作系统的交互。其次，它获得操作系统崩溃处理程序的地址，以便我们可以更快地检测到 Crash 而不是等待超时。第三，它可以返回某些驱动程序的地址，这些地址可用于限制跟踪所述驱动程序的活动，从而提高了在仅对个别驱动程序进行模糊处理时的性能
 - 支持的 CPU。必须使用支持 VT-x 和 PT 的 CPU，Intel 在哪些 CPU 上完全支持虚拟机和各种其他扩展的表述非常模糊
 - JIT 代码。Intel PT 不提供已执行指令指针的完整列表。相反，Intel PT 会根据需要生成尽可能少的信息，以减少处理器产生的数据量。因此，Intel PT 的软件解码器不仅需要控制流信息来重新构建控制流，而且还需要在跟踪期间执行的程序。如果程序在运行时被修改，就像用户和内核模式下的即时（JIT）编译器经常进行的那样，解码器无法完全恢复运行时控制流
 - 多字节比较。与 AFL 类似，我们无法有效绕过检查输入中的大魔术值。但是，如果预先知道这些魔术值（例如，来自 RFC、源代码或反汇编），我们支持指定有用的常量的字典以提高性能。已经提出了涉及诸如混合执行（例如 Driller）或污点跟踪（例如 Vuzzer）等技术的一些解决方案。但是，这些技术都不能轻易适用于闭源操作系统内核
 - ring 3 Fuzzing。只针对内核级代码演示了这种技术，也可以使用完全相同的技术模拟闭源 ring 3 代码


  [1]: http://static.zybuluo.com/Titan/yfx7tngimietfihibc4xfzvl/image_1c7tmebg31joh49n1a4p14n71fgh9.png
  [2]: http://static.zybuluo.com/Titan/c7zen6raxpuarzycep5xrd2p/image_1c7uupbjd1hpe1d9h1fi719681u5mm.png
  [3]: http://static.zybuluo.com/Titan/m4a0y2x43xntqi21qvwdfxvd/image_1c7vetvldhi7rj601krijcu13.png
  [4]: http://static.zybuluo.com/Titan/eobvrey13jb83wjg2pae9p8j/image_1c7vg62qc1cogr551vh812c118ap1g.png
  [5]: http://static.zybuluo.com/Titan/67jlfbepa2jowljgg121hztd/image_1c7vi0jndju61ji11gie2i21aeh2d.png